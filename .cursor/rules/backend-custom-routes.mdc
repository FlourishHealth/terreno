---
description: When creating a custom route in the backend that doesn't map cleanly to a CRUD REST API.
alwaysApply: false
---
## Creating Custom Routes

Custom routes are useful when an action doesn't map cleanly to REST semantics or if
we need to combine data or fetch data in a way that doesn't neatly conform to ModelRouter.

When creating custom API routes, follow these patterns consistently:

### 1. Route File Structure

Create a new file in `backend/src/api/` with the following structure:

```typescript
import type {Request, Response} from "express";
import {
  APIError,
  asyncHandler,
  authenticateMiddleware,
  ModelRouterOptions,
  createOpenApiBuilder,
} from "@terreno/api";

import {/* your models */} from "../models";
import {/* your types */} from "../types";

// Define OpenAPI middleware function using the builder pattern
const yourRouteOpenApiMiddleware = (options: Partial<ModelRouterOptions<any>>) => {
  return createOpenApiBuilder(options)
    .withTags(["yourTag"])
    .withSummary("Brief summary of what this endpoint does")
    .withDescription("Detailed description of the endpoint")
    .withPathParameter("paramName", {type: "string"}, {
      description: "Description of the parameter",
    })
    .withResponse(200, {
      data: {
        type: "object",
        description: "Response data",
        properties: {
          id: {type: "string"},
          name: {type: "string"},
        },
      },
    })
    .build();
};

export const addYourRoutes = (
  router: any,
  options: Partial<ModelRouterOptions<any>>
): void => {
  router.get(
    "/yourRoute/:paramName",
    [
      authenticateMiddleware(),
      yourRouteOpenApiMiddleware(options),
    ],
    asyncHandler(async (req: Request, res: Response) => {
      const user = req.user as UserDocument;

      if (!req.params.paramName) {
        throw new APIError({status: 400, title: "Missing parameter"});
      }

      const result = await yourLogic();

      return res.json({data: result});
    })
  );
};
```

### Builder Methods

- `.withTags(tags: string[])` - Add OpenAPI tags for documentation grouping
- `.withSummary(summary: string)` - Short description
- `.withDescription(description: string)` - Detailed description
- `.withPathParameter(name, schema, options?)` - Add path parameter
- `.withQueryParameter(name, schema, options?)` - Add query parameter
- `.withRequestBody(schema, options?)` - Define request body schema (POST/PUT/PATCH)
- `.withResponse(statusCode, schema, options?)` - Define response schema
- `.withArrayResponse(statusCode, itemSchema, options?)` - Define array response
- `.build()` - **REQUIRED**: Builds and returns the middleware

### Required Middleware Components

Every custom route MUST include:

1. **authenticateMiddleware()**: For authentication
   - `authenticateMiddleware()` for required auth
   - `authenticateMiddleware(false)` for optional auth

2. **OpenAPI middleware**: For API documentation
   - Use `createOpenApiBuilder(options)...build()`

3. **asyncHandler()**: Wrap the route handler

### Export and Register Routes

1. Export from `backend/src/api/index.ts`:
```typescript
export * from "./yourRoutes";
```

2. Register in server:
```typescript
import {addYourRoutes} from "./api";
addYourRoutes(router, options);
```

### Generate SDK

After creating custom routes, regenerate the SDK:
```bash
bun run sdk
```

### Using the SDK (Frontend)

Always use the generated SDK hooks - never use `axios` directly:

```typescript
import {useGetYourRouteQuery} from "@/store/openApiSdk";

const {data, isLoading, error} = useGetYourRouteQuery({paramName: "value"});
```

### Best Practices

- **Error Handling**: Throw `APIError` with status and title
- **Validation**: Validate inputs at start of handler
- **Logging**: Use `logger.info/warn/error/debug`
- **Types**: Type `req.user` as `UserDocument`
- **Response Format**: Return `{data: ...}` for consistency
