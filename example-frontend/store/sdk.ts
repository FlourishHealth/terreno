// This takes the autogenerated SDK and adds some extra functionality to it. For example,
// we can add extra tags to endpoints.

import {generateTags} from "@terreno/rtk";
import startCase from "lodash/startCase";

import {addTagTypes, openapi} from "./openApiSdk";

// This is where we can modify the SDK. For example,
// we can add a transformResponse to the endpoints or we can add extra tags. We can also add extra
// endpoints, since we don't automatically generate for endpoints that don't use the router
// currently.

// Profile response type
export interface ProfileResponse {
  data: {
    _id: string;
    id: string;
    email: string;
    name: string;
    admin?: boolean;
  };
}

// AI Request Explorer types
export interface AIRequestExplorerItem {
  _id: string;
  aiModel: string;
  created: string;
  error?: string;
  prompt: string;
  requestType: string;
  response?: string;
  responseTime?: number;
  tokensUsed?: number;
  user?: {email?: string; name?: string};
  userId?: string;
}

export interface AIRequestExplorerResponse {
  data: AIRequestExplorerItem[];
  limit: number;
  more: boolean;
  page: number;
  total: number;
}

export interface AIRequestExplorerParams {
  endDate?: string;
  limit?: number;
  page?: number;
  requestType?: string;
  startDate?: string;
}

// Profile update request type
export interface UpdateProfileRequest {
  name?: string;
  email?: string;
  password?: string;
}

export const terrenoApi = openapi
  .injectEndpoints({
    endpoints: (builder) => ({
      // AI Request Explorer (admin only)
      getAiRequestsExplorer: builder.query<
        AIRequestExplorerResponse,
        AIRequestExplorerParams | undefined
      >({
        query: (params) => ({
          method: "GET",
          params: params ?? {},
          url: "/aiRequestsExplorer",
        }),
      }),
      // Get current user profile
      getMe: builder.query<ProfileResponse, void>({
        providesTags: ["profile"],
        query: () => ({
          method: "GET",
          url: "/auth/me",
        }),
      }),
      // Update current user profile
      patchMe: builder.mutation<ProfileResponse, UpdateProfileRequest>({
        invalidatesTags: ["profile"],
        query: (body) => ({
          body,
          method: "PATCH",
          url: "/auth/me",
        }),
      }),
    }),
  })
  // Enhance endpoints is where we can add different tags to endpoints and more complex
  // invalidations.
  .enhanceEndpoints({
    addTagTypes: ["consentForms", "gptHistories", "profile"],
    endpoints: {
      ...generateTags(openapi, [...addTagTypes]),
      postTodos: {invalidatesTags: ["todos"]},
    },
  });

export const {
  useEmailLoginMutation,
  useGoogleLoginMutation,
  useCreateEmailUserMutation,
  useEmailSignUpMutation,
  useResetPasswordMutation,
  useGetMeQuery,
  usePatchMeMutation,
  useGetAiRequestsExplorerQuery,
} = terrenoApi;
export * from "./openApiSdk";

// Endpoint type from the OpenAPI generated SDK - uses Record for dynamic structure
type OpenApiEndpoints = Record<string, unknown>;

// Get hooks from the @terreno/rtk generated SDK for CRUD/list operations.
// Returns the appropriate RTK Query hook based on model name and operation type
// Return type is Record<string, unknown> as it varies based on operation and model
export const getSdkHook = (
  modelName: string,
  type: "list" | "read" | "create" | "update" | "remove"
): Record<string, unknown> => {
  const modelPath = startCase(modelName).replace(/\s/g, "");
  const endpoints = openapi.endpoints as OpenApiEndpoints;
  switch (type) {
    case "list":
      return endpoints[`get${modelPath}`] as Record<string, unknown>;
    case "read":
      return endpoints[`get${modelPath}ById`] as Record<string, unknown>;
    case "create":
      return endpoints[`post${modelPath}`] as Record<string, unknown>;
    case "update":
      return endpoints[`patch${modelPath}ById`] as Record<string, unknown>;
    case "remove":
      return endpoints[`delete${modelPath}ById`] as Record<string, unknown>;
    default:
      throw new Error(`Invalid SDK hook: ${modelName}/${type}`);
  }
};
